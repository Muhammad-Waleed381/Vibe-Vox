<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VibeVox MVP</title>
  <style>
    :root {
      --bg: #f5f2ec;
      --panel: #fff8ee;
      --ink: #1f1c17;
      --accent: #b45a2b;
      --accent-dark: #8e4521;
      --muted: #6b6156;
    }

    [data-theme="dark"] {
      --bg: #1a1814;
      --panel: #26231f;
      --ink: #eaddcf;
      --accent: #d47a4b;
      --accent-dark: #e88d60;
      --muted: #a69b90;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "IBM Plex Serif", "Georgia", serif;
      color: var(--ink);
      background: radial-gradient(800px 400px at 20% 20%, var(--bg), transparent),
        linear-gradient(180deg, var(--bg) 0%, var(--panel) 100%);
      transition: background 0.3s ease, color 0.3s ease;
    }

    .wrap {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 32px 16px;
    }

    .panel {
      width: min(880px, 95vw);
      background: var(--panel);
      border: 1px solid #e3d5c3;
      border-radius: 16px;
      box-shadow: 0 18px 40px rgba(48, 32, 18, 0.15);
      padding: 28px;
      position: relative;
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }

    h1 {
      font-size: 28px;
      margin: 0 0 8px;
      letter-spacing: 0.4px;
    }

    p {
      margin: 0 0 20px;
      color: var(--muted);
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-bottom: 16px;
    }

    input,
    textarea {
      width: 100%;
      border: 1px solid #d9c8b5;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      color: var(--ink);
      background: var(--bg);
      transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    input:focus,
    textarea:focus {
      border-color: var(--accent);
      outline: none;
    }

    textarea {
      min-height: 160px;
      resize: vertical;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-size: 14px;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      transition: transform 0.15s ease, background 0.15s ease;
    }

    button:hover {
      background: var(--accent-dark);
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .status {
      margin-top: 12px;
      font-size: 13px;
      color: var(--muted);
    }

    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      background: #ead7c5;
      color: #6a3a1c;
      font-size: 12px;
      margin-left: 8px;
    }

    .emotion-panel {
      margin-top: 16px;
      padding: 16px;
      background: #faf8f5;
      border: 1px solid #e3d5c3;
      border-radius: 12px;
      max-height: 300px;
      overflow-y: auto;
    }

    .emotion-panel h3 {
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--muted);
    }

    .emotion-chip {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      margin: 3px;
      background: #e8e0d5;
    }

    .emotion-chip.joy {
      background: #fff3cd;
      color: #856404;
    }

    .emotion-chip.sadness {
      background: #d4edda;
      color: #155724;
    }

    .emotion-chip.anger {
      background: #f8d7da;
      color: #721c24;
    }

    .emotion-chip.fear {
      background: #e2e3e5;
      color: #383d41;
    }

    .emotion-chip.excitement {
      background: #ffeeba;
      color: #856404;
    }

    .emotion-chip.suspense {
      background: #d6d8d9;
      color: #1b1e21;
    }

    .chunk-item {
      padding: 8px;
      margin: 4px 0;
      border-radius: 6px;
      background: #fff;
      border-left: 3px solid var(--accent);
      font-size: 13px;
    }

    .chunk-item.active {
      background: #fff3e0;
      border-left-color: var(--accent-dark);
    }

    .progress-bar {
      height: 4px;
      background: #e3d5c3;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }



    .char-count {
      text-align: right;
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .theme-toggle {
      position: absolute;
      top: 24px;
      right: 24px;
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--muted);
      padding: 6px 10px;
      font-size: 18px;
      line-height: 1;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s ease, color 0.2s ease;
    }

    .theme-toggle:hover {
      transform: rotate(15deg);
      color: var(--ink);
      background: rgba(0, 0, 0, 0.05);
    }

    [data-theme="dark"] .theme-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Loading Spinner */
    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 0.8s ease-in-out infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    button.processing {
      opacity: 0.8;
      cursor: wait;
      pointer-events: none;
    }

    /* Toasts */
    #toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: var(--panel);
      border: 1px solid #e3d5c3;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 280px;
      max-width: 400px;
      animation: slideIn 0.3s ease forwards;
      pointer-events: auto;
    }

    .toast.error {
      border-left: 44px solid #dc3545;
    }

    .toast.success {
      border-left: 4px solid #28a745;
    }

    .toast.info {
      border-left: 4px solid var(--accent);
    }

    /* Karaoke Overlay */
    #karaoke_display {
      margin-top: 12px;
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(180, 90, 43, 0.1);
      border-left: 4px solid var(--accent);
      border-radius: 6px;
      font-style: italic;
      min-height: 40px;
      display: none;
      transition: opacity 0.3s;
    }

    /* Recording Dot */
    .rec-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      background: red;
      border-radius: 50%;
      margin-right: 4px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    /* Zen Mode */
    body.zen-mode .zen-hide {
      display: none !important;
    }

    body.zen-mode .panel {
      border: none;
      box-shadow: none;
      background: transparent;
      padding-top: 0;
    }

    body.zen-mode #text {
      min-height: 50vh;
      font-size: 18px;
      line-height: 1.6;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.05);
      /* subtle */
    }

    body.zen-mode #text:focus {
      outline: none;
      background: var(--bg);
      border-color: var(--accent);
    }


    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* Visualizer */
    #visualizer {
      width: 100%;
      height: 60px;
      background: rgba(0, 0, 0, 0.03);
      /* Subtle bg */
      border-radius: 8px;
      margin-top: 12px;
      display: block;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div style="position: absolute; top: 24px; right: 24px;">
        <button id="zen_toggle" class="theme-toggle" style="margin-right: 8px;" title="Zen Mode">üßò</button>
        <button id="theme_toggle" class="theme-toggle" title="Toggle Theme">üåó</button>
      </div>
      <div id="toast-container"></div>

      <h1 class="zen-hide">VibeVox MVP</h1>
      <h1 class="zen-hide">VibeVox MVP</h1>
      <p class="zen-hide">Live adaptive narration: text ‚Üí emotion ‚Üí style prompt ‚Üí Qwen3-TTS, streamed as it‚Äôs
        generated.</p>

      <!-- Presets -->
      <div class="zen-hide" style="margin-bottom: 16px; display: flex; gap: 8px; flex-wrap: wrap;">
        <span style="font-size: 13px; font-weight: 600; color: var(--muted); align-self: center;">Presets:</span>
        <button class="preset-btn" onclick="applyPreset('story')"
          style="padding: 4px 10px; font-size: 12px; background: #e3d5c3; color: #5a4a3a;">üìñ Storyteller</button>
        <button class="preset-btn" onclick="applyPreset('news')"
          style="padding: 4px 10px; font-size: 12px; background: #e3d5c3; color: #5a4a3a;">üì∞ News</button>
        <button class="preset-btn" onclick="applyPreset('asmr')"
          style="padding: 4px 10px; font-size: 12px; background: #e3d5c3; color: #5a4a3a;">ü§´ ASMR</button>
      </div>

      <div class="grid zen-hide">
        <div>
          <label for="port">TTS Server Port</label>
          <input id="port" type="number" value="5000" min="1" max="65535" />
        </div>
        <div>
          <label for="speaker">Speaker Identity (Optional)</label>
          <input id="speaker" type="text" value="Male_Narrator" placeholder="Only if not cloning..." />
        </div>
        <div>
          <label for="groq_model">Groq Model</label>
          <input id="groq_model" type="text" value="llama-3.1-8b-instant" />
        </div>
        <div>
          <label for="crossfade">Crossfade (ms)</label>
          <input id="crossfade" type="number" value="50" min="0" max="500" />
        </div>
        <div>
          <label for="rate">Speaking Rate: <span id="rate_value">1.0x</span></label>
          <input id="rate" type="range" class="rate-slider" value="1.0" min="0.5" max="2.0" step="0.1" />
        </div>
      </div>

      <div class="zen-hide"
        style="margin-bottom: 16px; padding: 16px; background: var(--bg); border: 1px dashed #d9c8b5; border-radius: 12px;">
        <label style="color: var(--accent-dark);">üéôÔ∏è Voice Cloning (Override Speaker)</label>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 8px;">
          <div>
            <label for="ref_audio" style="font-weight: normal; font-size: 13px;">Reference Audio (WAV/MP3)</label>
            <div style="display: flex; gap: 8px;">
              <input id="ref_audio" type="file" accept="audio/*" style="flex-grow: 1;" />
              <button id="record_btn" style="background: var(--muted); width: 40px;"
                title="Record Microphone">üé§</button>
            </div>
            <div id="record_status" style="font-size: 11px; color: var(--accent); margin-top: 4px; display: none;">
              Recording...</div>
          </div>
          <div>
            <label for="ref_text" style="font-weight: normal; font-size: 13px;">Reference Transcript</label>
            <input id="ref_text" type="text" placeholder="What is said in the audio?" />
          </div>
        </div>
      </div>

      <div class="zen-hide"
        style="margin-bottom: 16px; padding: 16px; background: var(--bg); border: 1px dashed #d9c8b5; border-radius: 12px;">
        <label style="color: var(--accent-dark);">üìÑ Document Upload (PDF, EPUB, TXT)</label>
        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; margin-top: 8px;">
          <div>
            <label for="doc_file" style="font-weight: normal; font-size: 13px;">Select a document file</label>
            <input id="doc_file" type="file" accept=".pdf,.epub,.txt,.text" />
          </div>
          <div style="display: flex; align-items: flex-end;">
            <button id="load_doc" style="background: var(--muted);">Load Document</button>
          </div>
        </div>
        <div id="doc_info" class="status" style="margin-top: 8px; display: none;"></div>
      </div>

      <div>
        <div style="display: flex; justify-content: space-between; align-items: baseline;">
          <label for="text" class="zen-hide">Text to Speak</label>
          <div style="font-size: 13px;">
            <button id="dice_btn"
              style="padding: 2px 8px; margin-right: 4px; background: var(--muted); font-size: 12px;"
              title="Random Prompt">üé≤</button>
            <button id="history_btn"
              style="padding: 2px 8px; margin-right: 8px; background: var(--muted); font-size: 12px;">üïí
              History</button>
            <span id="duration_est" style="color: var(--accent);">~0s</span>
          </div>
        </div>
        <textarea id="text">The hallway was quiet. He paused, listening for any sound.</textarea>
        <div id="char_count" class="char-count">0 chars</div>
      </div>

      <div class="actions" style="margin-top: 12px;">
        <button id="analyze">Analyze Emotions</button>
      </div>

      <div id="emotion_panel" class="emotion-panel" style="display: none;">
        <h3>Emotion Analysis</h3>
        <div id="emotion_summary"></div>
        <div id="chunk_list" style="margin-top: 12px;"></div>
      </div>

      <div class="actions" style="margin-top: 16px;">
        <button id="live">Live Clone & Play</button>
        <button id="stop" disabled>Stop</button>
        <button id="export">Export Audiobook</button>
        <span class="badge" id="status">Idle</span>
      </div>

      <!-- ... (Audio player and status divs remain same) ... -->
      <div style="margin-top: 12px;">
        <!-- ... (Audio player and status divs remain same) ... -->
        <div style="margin-top: 12px;">
          <div id="karaoke_display"></div>
          <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 8px;">
            <audio id="player" controls style="flex-grow: 1;"></audio>
            <div style="display: flex; align-items: center; gap: 4px;">
              <span style="font-size: 14px;">üîä Boost</span>
              <input id="vol_boost" type="range" min="1" max="3" step="0.1" value="1" style="width: 80px;"
                title="Volume Boost (100% - 300%)">
            </div>
          </div>
          <canvas id="visualizer" width="800" height="60"></canvas>
        </div>
        <div class="progress-bar">
          <div id="progress_fill" class="progress-fill" style="width: 0%;"></div>
        </div>

        <div class="status" style="margin-top: 10px;">
          <a id="download" href="#" style="display: none;">Download export</a>
        </div>
        <div class="status" id="detail"></div>
      </div>
    </div>

    <script>
      // ... (Get Element IDs) ...
      const liveBtn = document.getElementById("live");
      const stopBtn = document.getElementById("stop");
      const exportBtn = document.getElementById("export");
      const statusBadge = document.getElementById("status");
      const detail = document.getElementById("detail");
      const downloadLink = document.getElementById("download");
      const portInput = document.getElementById("port");
      const speakerInput = document.getElementById("speaker");
      const groqModelInput = document.getElementById("groq_model");
      const crossfadeInput = document.getElementById("crossfade");
      const textInput = document.getElementById("text");
      const player = document.getElementById("player");
      const refAudioInput = document.getElementById("ref_audio");
      const refTextInput = document.getElementById("ref_text");
      const docFileInput = document.getElementById("doc_file");
      const loadDocBtn = document.getElementById("load_doc");
      const docInfo = document.getElementById("doc_info");
      const analyzeBtn = document.getElementById("analyze");
      const emotionPanel = document.getElementById("emotion_panel");
      const emotionSummary = document.getElementById("emotion_summary");
      const chunkList = document.getElementById("chunk_list");
      const rateInput = document.getElementById("rate");
      const rateValue = document.getElementById("rate_value");

      const progressFill = document.getElementById("progress_fill");
      const themeToggleBtn = document.getElementById("theme_toggle");
      const charCountDisplay = document.getElementById("char_count");

      // New Elements
      const toastContainer = document.getElementById("toast-container");
      const visualizer = document.getElementById("visualizer");
      const durationEstDisplay = document.getElementById("duration_est");
      const historyBtn = document.getElementById("history_btn");
      const volBoostInput = document.getElementById("vol_boost");

      // Round 2 Elements
      const recordBtn = document.getElementById("record_btn");
      const recordStatus = document.getElementById("record_status");
      const diceBtn = document.getElementById("dice_btn");
      const karaokeDisplay = document.getElementById("karaoke_display");
      const zenToggle = document.getElementById("zen_toggle");
      // exportBtn is already defined

      // --- Persistent Settings & Theme ---
      const STORAGE_KEY_PREFIX = "vibevox_";
      const SETTINGS_INPUTS = ["port", "speaker", "groq_model", "crossfade", "rate", "text"];

      function loadSettings() {
        // Load Inputs
        SETTINGS_INPUTS.forEach(id => {
          const val = localStorage.getItem(STORAGE_KEY_PREFIX + id);
          if (val) {
            const el = document.getElementById(id);
            if (el) {
              el.value = val;
              // Trigger events for sliders/etc if needed
              if (id === 'rate') {
                playbackRate = parseFloat(val);
                if (rateValue) rateValue.textContent = playbackRate.toFixed(1) + "x";
              }
            }
          }
        });

        // Load Theme
        const storedTheme = localStorage.getItem(STORAGE_KEY_PREFIX + "theme");
        if (storedTheme === "dark") {
          document.documentElement.setAttribute("data-theme", "dark");
        }

        // Init Char Count
        updateCharCount();
      }

      function saveSetting(id, value) {
        localStorage.setItem(STORAGE_KEY_PREFIX + id, value);
      }

      function toggleTheme() {
        const current = document.documentElement.getAttribute("data-theme");
        const newTheme = current === "dark" ? "light" : "dark";

        if (newTheme === "dark") {
          document.documentElement.setAttribute("data-theme", "dark");
        } else {
          document.documentElement.removeAttribute("data-theme");
        }
        localStorage.setItem(STORAGE_KEY_PREFIX + "theme", newTheme);
      }

      function updateCharCount() {
        const len = textInput.value.length;
        charCountDisplay.textContent = `${len} chars`;

        // Update duration est (Approx 150 wpm at 1.0x)
        const words = textInput.value.trim().split(/\s+/).length;
        const rate = parseFloat(rateInput.value) || 1.0;
        const seconds = Math.ceil((words / 150) * 60 * (1 / rate));
        durationEstDisplay.textContent = `~${seconds}s`;
      }

      // Initialize
      loadSettings();

      // Event Listeners for Persistence
      SETTINGS_INPUTS.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener("input", (e) => {
            saveSetting(id, e.target.value);
            if (id === "text") updateCharCount();
            if (id === "rate") updateCharCount();
          });
          el.addEventListener("change", (e) => saveSetting(id, e.target.value));
        }
      });

      themeToggleBtn.addEventListener("click", toggleTheme);
      zenToggle.addEventListener("click", () => {
        document.body.classList.toggle("zen-mode");
      });

      // Shortcuts
      document.addEventListener("keydown", (e) => {
        // Ctrl+Enter -> Analyze
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          if (!analyzeBtn.disabled) analyzeBtn.click();
        }
        // Shift+Enter -> Live Clone
        if (e.shiftKey && e.key === "Enter") {
          e.preventDefault(); // prevent new line
          if (!liveBtn.disabled) liveBtn.click();
        }
        // Space -> Toggle Play (only if not focused on input)
        if (e.code === "Space" && e.target.tagName !== "TEXTAREA" && e.target.tagName !== "INPUT") {
          e.preventDefault();
          if (player.paused) player.play(); else player.pause();
        }
      });

      // History
      historyBtn.addEventListener("click", () => {
        const hist = JSON.parse(localStorage.getItem(STORAGE_KEY_PREFIX + "prompt_history") || "[]");
        if (hist.length === 0) {
          showToast("No history found", "info");
          return;
        }
        // Simple prompt for MVP (could be modal)
        const choice = prompt("Enter number to restore:\n" + hist.map((t, i) => `${i + 1}. ${t.substring(0, 40)}...`).join("\n"));
        const idx = parseInt(choice) - 1;
        if (hist[idx]) {
          textInput.value = hist[idx];
          updateCharCount();
          showToast("Restored from history", "success");
        }
      });

      function saveToHistory(text) {
        if (!text) return;
        let hist = JSON.parse(localStorage.getItem(STORAGE_KEY_PREFIX + "prompt_history") || "[]");
        // Remove duplicate if exists
        hist = hist.filter(t => t !== text);
        // Add to front
        hist.unshift(text);
        // Limit to 10
        if (hist.length > 10) hist.pop();
        localStorage.setItem(STORAGE_KEY_PREFIX + "prompt_history", JSON.stringify(hist));
        localStorage.setItem(STORAGE_KEY_PREFIX + "prompt_history", JSON.stringify(hist));
      }

      // --- Round 2 Logic ---

      // Presets
      window.applyPreset = function (type) {
        if (type === 'story') {
          rateInput.value = 0.9;
          crossfadeInput.value = 100;
        } else if (type === 'news') {
          rateInput.value = 1.1;
          crossfadeInput.value = 20;
        } else if (type === 'asmr') {
          rateInput.value = 0.7;
          crossfadeInput.value = 200;
        }
        // Trigger save
        rateInput.dispatchEvent(new Event('input'));
        crossfadeInput.dispatchEvent(new Event('input'));
        showToast(`Applied ${type} preset`, 'success');
      };

      // Random Prompts
      const RANDOM_PROMPTS = [
        "The ancient door creaked open, revealing a room filled with swirling dust and golden light.",
        "I can't believe you did that! After everything we've been through?",
        "Breaking news: Scientists have discovered a new planet capable of sustaining life.",
        "He whispered into the microphone, his voice trembling with anticipation.",
        "The quick brown fox jumps over the lazy dog, but the dog didn't seem to mind."
      ];
      diceBtn.addEventListener('click', () => {
        const item = RANDOM_PROMPTS[Math.floor(Math.random() * RANDOM_PROMPTS.length)];
        textInput.value = item;
        updateCharCount();
      });

      // Recording
      let mediaRecorder = null;
      let recordedChunks = [];
      let recordedAudioBlob = null;
      let isRecording = false;

      recordBtn.addEventListener('click', async () => {
        if (isRecording) {
          // Stop
          mediaRecorder.stop();
          isRecording = false;
          recordBtn.textContent = "üé§";
          recordBtn.style.background = "var(--muted)";
          recordStatus.style.display = "none";
        } else {
          // Start
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            recordedChunks = [];

            mediaRecorder.ondataavailable = e => {
              if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
              recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
              showToast("Recording saved for cloning!", "success");
              // Visual feedback that we have loopback audio
              refAudioInput.value = ""; // Clear file input
            };

            mediaRecorder.start();
            isRecording = true;
            recordBtn.innerHTML = "<span class='rec-dot'></span>";
            recordBtn.style.background = "#333";
            recordStatus.style.display = "block";
          } catch (err) {
            showToast("Microphone access denied", "error");
          }
        }
      });

      // --- End Persistent Settings ---


      // ... (Helper functions remain same) ...
      let controller = null;
      let audioCtx = null;
      let masterGain = null; // Volume booster
      let analyser = null; // Visualizer
      let nextStartTime = 0;
      let sources = [];
      let exportPoll = null;
      let exportJobId = null;
      let playbackRate = 1.0;
      let currentChunkIndex = 0;
      let totalChunks = 0;
      let playbackRate = 1.0;
      let currentChunkIndex = 0;
      let totalChunks = 0;
      let visualizerFrame = null;

      // Client-Side Export
      let destStream = null;
      let outputRecorder = null;
      let outputChunks = [];

      // --- UI Helpers ---
      function showToast(message, type = "info") {
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;

        let icon = "‚ÑπÔ∏è";
        if (type === "error") icon = "‚ùå";
        if (type === "success") icon = "‚úÖ";

        toast.innerHTML = `<span>${icon}</span> <span>${message}</span>`;
        toastContainer.appendChild(toast);

        // Auto remove
        setTimeout(() => {
          toast.style.animation = "fadeOut 0.3s ease forwards";
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }

      function setBtnProcessing(btn, isProcessing, originalText) {
        if (isProcessing) {
          btn.classList.add("processing");
          btn.dataset.originalText = btn.textContent;
          btn.innerHTML = `<span class="spinner"></span> ${originalText || "Processing..."}`;
        } else {
          btn.classList.remove("processing");
          btn.textContent = btn.dataset.originalText || "Action";
        }
      }
      // ------------------

      function setStatus(label, info) {
        statusBadge.textContent = label;
        detail.textContent = info || "";
        // Optional: Log important status changes to toast? 
        // Keeping separate for now as status badge is persistent.
      }

      function clearDownload() {
        if (!downloadLink) return;
        downloadLink.style.display = "none";
        downloadLink.href = "#";
        downloadLink.removeAttribute("download");
      }

      function setDownload(url, filename) {
        if (!downloadLink) return;
        downloadLink.style.display = "inline-block";
        downloadLink.href = url;
        if (filename) downloadLink.setAttribute("download", filename);
      }

      function decodeBase64ToBytes(b64) {
        const binary = atob(b64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      function stopAudio() {
        for (const node of sources) {
          try { node.stop(); } catch (_) { }
        }
        sources = [];
        nextStartTime = 0;
        if (audioCtx) {
          try { audioCtx.close(); } catch (_) { }
        }
        if (visualizerFrame) cancelAnimationFrame(visualizerFrame);
        audioCtx = null;
        masterGain = null;
        analyser = null;
        destStream = null;
        outputRecorder = null;

        karaokeDisplay.style.display = 'none';
      }

      // ... (stopExportPolling, stop, getCrossfadeSeconds, scheduleBuffer remain same) ...

      function stopExportPolling() {
        if (exportPoll) {
          clearInterval(exportPoll);
          exportPoll = null;
        }
        exportJobId = null;
      }

      function stop() {
        if (controller) controller.abort();
        controller = null;
        stopExportPolling();
        stopAudio();
        clearDownload();
        if (player) {
          player.pause();
          player.removeAttribute("src");
          player.load();
        }
        progressFill.style.width = "0%";
        document.querySelectorAll(".chunk-item").forEach(el => el.classList.remove("active"));
        currentChunkIndex = 0;
        totalChunks = 0;

        setBtnProcessing(liveBtn, false);
        setBtnProcessing(analyzeBtn, false);
        setBtnProcessing(loadDocBtn, false);

        // Save Export if exists
        if (outputChunks.length > 0) {
          const blob = new Blob(outputChunks, { type: 'audio/wav' });
          const url = URL.createObjectURL(blob);
          setDownload(url, `vibevox_export_${Date.now()}.wav`);
          showToast("Export ready for download", "success");
        }

        liveBtn.disabled = false;
        exportBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus("Idle", "");
      }

      function getCrossfadeSeconds() {
        const ms = Number(crossfadeInput.value || "50");
        if (!Number.isFinite(ms)) return 0.05;
        return Math.max(0, Math.min(ms, 500)) / 1000.0;
      }

      function scheduleBuffer(audioBuffer, crossfadeSec, chunkIdx) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const fade = Math.min(crossfadeSec, audioBuffer.duration / 2);
        const startAt = Math.max(nextStartTime ? (nextStartTime - fade) : (now + 0.05), now + 0.02);
        nextStartTime = startAt + audioBuffer.duration;

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = playbackRate;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0, startAt);
        gain.gain.linearRampToValueAtTime(1, startAt + fade);
        gain.gain.setValueAtTime(1, Math.max(startAt + fade, nextStartTime - fade));
        gain.gain.linearRampToValueAtTime(0, nextStartTime);

        // Connect to master gain instead of straight destination
        if (masterGain) {
          source.connect(gain).connect(masterGain);
        } else {
          source.connect(gain).connect(audioCtx.destination);
        }

        source.start(startAt);
        sources.push(source);

        updateProgress(chunkIdx);
      }

      // --- Visualizer ---
      function drawVisualizer() {
        if (!analyser) return;
        const canvas = visualizer;
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg'); // clear with bg
        ctx.clearRect(0, 0, width, height);

        const barWidth = (width / bufferLength) * 2.5;
        let barHeight;
        let x = 0;

        const accent = getComputedStyle(document.body).getPropertyValue('--accent');

        for (let i = 0; i < bufferLength; i++) {
          barHeight = dataArray[i] / 2;
          ctx.fillStyle = accent;
          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }

        visualizerFrame = requestAnimationFrame(drawVisualizer);
      }

      function syncVolume() {
        if (masterGain) {
          masterGain.gain.value = parseFloat(volBoostInput.value);
        }
      }

      volBoostInput.addEventListener("input", syncVolume);
      // ------------------

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => {
            // Remove data:audio/xxx;base64, prefix
            const base64 = reader.result.split(',')[1];
            resolve(base64);
          };
          reader.onerror = error => reject(error);
        });
      }

      rateInput.addEventListener("input", () => {
        playbackRate = parseFloat(rateInput.value);
        rateValue.textContent = playbackRate.toFixed(1) + "x";
        if (player) {
          player.playbackRate = playbackRate;
        }
      });

      async function analyzeEmotions() {
        const text = textInput.value.trim();
        if (!text) {
          showToast("Text is required", "error");
          return;
        }

        setStatus("Analyzing", "Detecting emotions...");
        setBtnProcessing(analyzeBtn, true, "Analyzing...");

        try {
          const response = await fetch("/api/analyze_text", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              text,
              groq_model: groqModelInput.value || "llama-3.1-8b-instant"
            }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || "Failed to analyze text");
          }

          const data = await response.json();

          emotionSummary.innerHTML = "";
          for (const [emotion, count] of Object.entries(data.emotion_summary)) {
            const chip = document.createElement("span");
            chip.className = `emotion-chip ${emotion.toLowerCase()}`;
            chip.textContent = `${emotion} (${count})`;
            emotionSummary.appendChild(chip);
          }

          chunkList.innerHTML = "";
          data.chunks.forEach((chunk, idx) => {
            const item = document.createElement("div");
            item.className = "chunk-item";
            item.id = `chunk_${idx}`;
            item.innerHTML = `<strong>${chunk.emotion}</strong> [${chunk.intensity}] - ${chunk.text}`;
            chunkList.appendChild(item);
          });

          totalChunks = data.total_chunks;
          currentChunkIndex = 0;
          emotionPanel.style.display = "block";
          setStatus("Ready", `Analyzed: ${data.total_chunks} chunks`);

          // Success
          setBtnProcessing(analyzeBtn, false);

        } catch (err) {
          setBtnProcessing(analyzeBtn, false);
          setStatus("Error", "Analysis failed");
          showToast(err.message || "Failed to analyze emotions", "error");
        }
      }

      function updateProgress(chunkIdx) {
        if (totalChunks > 0) {
          const percent = ((chunkIdx + 1) / totalChunks) * 100;
          progressFill.style.width = percent + "%";
        }

        document.querySelectorAll(".chunk-item").forEach((el, idx) => {
          el.classList.toggle("active", idx === chunkIdx);
        });
        currentChunkIndex = chunkIdx;
      }

      async function loadDocument() {
        if (docFileInput.files.length === 0) {
          showToast("Please select a document file", "error");
          return;
        }

        const file = docFileInput.files[0];
        setStatus("Parsing", "Reading document...");
        setBtnProcessing(loadDocBtn, true, "Loading...");

        const formData = new FormData();
        formData.append("file", file);

        try {
          const response = await fetch("/api/parse_document", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || "Failed to parse document");
          }

          const data = await response.json();
          textInput.value = data.text;

          docInfo.style.display = "block";
          docInfo.textContent = `Loaded: ${data.filename} (${data.word_count} words)`;

          setStatus("Ready", `Document loaded: ${data.word_count} words`);
          showToast(`Loaded ${data.filename}`, "success");
          updateCharCount(); // update stats
        } catch (err) {
          setStatus("Error", "Load failed");
          showToast(err.message || "Failed to load document", "error");
        } finally {
          setBtnProcessing(loadDocBtn, false);
        }
      }

      async function livePlay() {
        stop();
        const text = textInput.value.trim();
        if (!text) {
          showToast("Text is required", "error");
          return;
        }

        saveToHistory(text); // Save to history

        // Recording Override
        let refAudioB64 = null;
        if (recordedAudioBlob) {
          // Use recorded blob
          setStatus("Preparing", "Encoding recorded audio...");
          try {
            refAudioB64 = await fileToBase64(recordedAudioBlob);
          } catch (e) {
            showToast("Failed to encode recording", "error");
            return;
          }
        } else if (refAudioInput.files.length > 0) {
          setStatus("Preparing", "Encoding reference audio...");
          try {
            refAudioB64 = await fileToBase64(refAudioInput.files[0]);
          } catch (e) {
            showToast("Failed to read audio file", "error");
            return;
          }
        }

        liveBtn.disabled = true;
        exportBtn.disabled = true;
        stopBtn.disabled = false;
        setStatus("Connecting", "Starting live stream...");
        setBtnProcessing(liveBtn, true, "Starting...");

        controller = new AbortController();
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Setup Master Gain & Visualizer
        masterGain = audioCtx.createGain();
        masterGain.gain.value = parseFloat(volBoostInput.value);
        masterGain.connect(audioCtx.destination);

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        masterGain.connect(analyser); // Visualize output
        drawVisualizer(); // Start loop

        // Setup Export Recording
        destStream = audioCtx.createMediaStreamDestination();
        masterGain.connect(destStream);
        outputRecorder = new MediaRecorder(destStream.stream);
        outputChunks = [];
        outputRecorder.ondataavailable = e => outputChunks.push(e.data);
        outputRecorder.start();

        await audioCtx.resume();

        const payload = {
          text,
          tts_port: Number(portInput.value || "5000"),
          speaker: speakerInput.value || "Male_Narrator",
          groq_model: groqModelInput.value || "llama-3.1-8b-instant",
          reference_audio: refAudioB64,
          reference_text: refTextInput.value.trim() || null,
        };

        try {
          const response = await fetch(`/api/speak_stream`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal: controller.signal,
          });
          // ... (Rest of streaming logic remains same) ...
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || "Failed to stream audio");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let chunkCount = null;
          let chunksSeen = 0;
          const crossfadeSec = getCrossfadeSeconds();

          setStatus("Streaming", "Waiting for first chunk...");

          // Once we start streaming, we might want to change the button state to "Playing" or just keep it processing until logic dictates
          // Actually, once playing starts, we can remove the spinner but keep it disabled, or keep spinner if we want to show "streaming"
          // For now, let's keep it processing until audio starts playing or we decide. 
          // Better yet: once first chunk arrives, we are "Live".


          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            while (true) {
              const nl = buffer.indexOf("\n");
              if (nl === -1) break;
              const line = buffer.slice(0, nl).trim();
              buffer = buffer.slice(nl + 1);
              if (!line) continue;

              const msg = JSON.parse(line);
              if (msg.type === "meta") {
                chunkCount = msg.chunk_count;
                setStatus("Streaming", `Preparing ${chunkCount} chunks...`);
                continue;
              }
              if (msg.type === "chunk") {
                chunksSeen += 1;
                // Remove spinner once we start receiving audio
                if (chunksSeen === 1) setBtnProcessing(liveBtn, false);

                setStatus("Playing", chunkCount ? `Chunk ${chunksSeen}/${chunkCount}` : `Chunk ${chunksSeen}`);

                // Karaoke Update
                if (chunksSeen <= chunkList.children.length) {
                  const activeItem = chunkList.children[chunksSeen - 1];
                  // activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Cloning keeps generated chunks synced?
                  // Actually the chunks might not match 1:1 if we don't have analysis first.
                  // But if we did analysis, we can try to map.
                  // For now, let's just show the text if available in the chunk msg
                }
                // The backend chunk msg doesn't strictly have text relative to analysis unless we map it.
                // However, we can use the "sentences" from analysis if they exist.
                // Easier implementation: The chunk message SHOULD contain the text segment if the backend sends it. 
                // Checking backend... backend sends 'audio_b64'. It might not send text.
                // If we assume 1:1 mapping with analysis:
                if (chunkList.children.length > 0 && (chunksSeen - 1) < chunkList.children.length) {
                  const item = chunkList.children[chunksSeen - 1];
                  item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  karaokeDisplay.textContent = item.innerText;
                  karaokeDisplay.style.display = 'block';
                }

                const bytes = decodeBase64ToBytes(msg.audio_b64);
                const ab = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
                const audioBuffer = await audioCtx.decodeAudioData(ab);
                scheduleBuffer(audioBuffer, crossfadeSec, chunksSeen - 1);
                continue;
              }
              if (msg.type === "done") {
                setStatus("Playing", "Stream complete (finishing playback)");

                if (outputRecorder && outputRecorder.state === 'recording') {
                  outputRecorder.stop();
                }

                liveBtn.disabled = false;
                exportBtn.disabled = false;
                if (sources.length) {
                  const last = sources[sources.length - 1];
                  last.onended = () => stop();
                } else {
                  stop();
                }
                return;
              }
              if (msg.type === "error") {
                throw new Error(msg.error || "Stream error");
              }
            }
          }
        } catch (err) {
          stop();
          setStatus("Error", err.message || "Streaming failed");
          showToast(err.message || "Streaming failed", "error");
        }
      }

      async function exportAudiobook() {
        // ... (Export needs similar update, but for brevity we focus on live play first as requested) ...
        stop();
        setStatus("Error", "Export not yet updated for cloning. Use Live Play.");
      }

      liveBtn.addEventListener("click", livePlay);
      stopBtn.addEventListener("click", stop);
      exportBtn.addEventListener("click", exportAudiobook);
      loadDocBtn.addEventListener("click", loadDocument);
      analyzeBtn.addEventListener("click", analyzeEmotions);
    </script>
</body>

</html>